// An account is referenced by (owner, subid).
// `owner` is a principal, `subid` a nat.
type SubId = nat;

// A virtual account is referenced by (owner, virid).
// `owner` is a principal, `virid` a nat.
type VirId = nat;

// TxInput describes a transaction. 
// Currently there is only one transaction type, `ftTransfer`.
// In the future new transaction types will be introduced.
//
// The information in TxInput can be seen as _instructions_ to carry out a
// transaction rather than the transaction itself. When processed, the
// instructions will lead to an actual transaction. A full description of the
// resulting transaction can, in certain cases, require more information than 
// what was specified in the intructions.  For example, TxInput can specify a
// `max` amount which will be translated to the real amount available only at
// processing time.  As another example, the sender's principal is not in
// TxInput because it is implicitly specified as the "caller" who submit the
// TxInput. But it would of course be required in a complete description of the
// transaction.
type TxInput = variant { ftTransfer : FtTransfer };

// FtTransfer describes a fungible token transfer from one account to another.
// `from` is the sending account.
// `to` is the receiving account. 
// `assetId` is the id of the token to be transferred.
// `amount` is the number of tokens to be transferred.
// Specifying `max` as `amount` transfers the entire available amount in the 
// sending account.
// `memo` is a vector of blobs which can be used to attach metadata that is 
// relevant for the sender or receiver.
//
// Backward compatibility:
// New fields can be added to the record in the future as long as they are
// optional. Old client code will not specify the new field and it will be set to
// null by Candid.
// For example, we can later introduce an optional `nonce` field that can 
// be used to enforce idempotency if desired. The default is `null` which
// means idempotency is not enforced. 
// As another example, we can later introduce an optional `fee` field that
// can be used to select one from several fee modes if desired. The default
// is `null` which means to use the ledger's default fee mode.
type FtTransfer = record {
  from : AccountReference;
  to : AccountReference;
  asset : AssetId;
  amount : variant {
    amount : nat;
    max;
  };
  memo : vec blob;
};
type AssetId = nat;

// The sending or receiving account can be an account, virtual account, or
// the "mint".
// `sub` specifies the account of the caller with the given SubId.
// `vir` specifies the virtual account of the given owner principal with the
// given VirId. The caller must have access to that virtual account or the 
// transfer will fail.
// `mint` specifies the "mint" of the given asset id. Sending to `mint` burns
// tokens. Sending from `mint` mints tokens. In both cases, the caller must be
// the controller of the given asset id or the transfer will fail. Only the
// controller can mint and burn tokens.
// 
// Backward compatibility:
// Since this is an input (i.e. argument), new variant cases can later be added.
// Old client will simply never supply the new cases. 
type AccountReference = variant {
  sub : SubId;
  vir : record { principal; VirId };
  mint;
};

// Transactions are assigned a globally unique id (gid) when they are submitted
// to the aggregator. The global id is valid forever and will never be re-used
// for a different transaction, even if the transaction fails in processing.
type GlobalId = record { nat; nat };

// The status of a gid at the aggregator can be either queued, pending or
// unavailable.
// `queued` means that the transaction is in the queue in the aggregator
// and has not yet been placed into a batch. In this case the status specifies
// the distance from the head of the queue measured in the number of 
// transactions that come before it.
// `pending` means that the transaction has been placed in a batch and the
// batch has been sent to the ledger, but the aggregator has not yet received
// the response, i.e. does not know for sure whether the batch was received.
// `unavailable` means one of the following:
// * the transaction has been received by the ledger and is no longer available
// at the aggregator
// * the transactions has been dropped permanently, i.e. has not been received 
// by the ledger, is no longer available at aggregator and will not be retried
// * the transaction was never known by this aggregator
//
// Technical note: the last case means that either the stream id in the gid is
// not the current stream of the aggregator or the stream id is correct but the
// stream position lies in the future.
//
// The protocol is designed such that the aggregator can discard its state
// during upgrades. Transactions in the queue will be dropped. The status of a
// gid that was issued before the upgrade will be `unavailable` after the
// upgrade.  However, the protocol is designed such that users can determine
// with certainty whether they have to resubmit the transaction or not by also
// querying the ledger.
//
// We call this type `GidStatus` rather than `GidStatus` to emphasize that the
// status is not dependent on the TxInput and that the status reveals no
// information about the TxInput. This is different from querying the ledger for
// transaction status. The ledger can return success or failure which depends on
// the actual TxInput, not only the gid.  When we query the aggregator for
// GidStatus we only learn about the progress of communication between
// aggregator and ledger which is only a function of gid, not the TxInput.
type GidStatus = variant { 
  queued : nat; 
  pending; 
  unavailable; 
};

// API

service : (principal, nat) -> {
  // UPDATES

  // `submitAndExecute` submits a transaction to the aggregator. The aggregator
  // returns the issued global id and the GidStatus immediately after enqueueing
  // the transaction. The purpose of returning GidStatus is so that the caller
  // knows the queue position without having to make another call.
  // 
  // The returned GidStatus is always `queued` (never `pending` or
  // `unavailable`), i.e. returning a GidStatus variant instead of only the queue
  // position has some redundancy. The reason to do so is to simplify the
  // calling code through unification. The assumption is that the calling code
  // will poll the `gidStatus` query function after submission. Hence the first
  // `GidStatus` returned by `submitAndExecute` can be fed into the same
  // processing logic as the return values obtained in the subsequent polling.
  // 
  // `submitAndExecute` will trap in the following cases: * A `SubId`, `VirId`
  // or `assetId` is larger than 64 bits * `amount` is larger than 128 bits *
  // The principal in `vir` is longer than 29 bytes or otherwise invalid * The
  // memo vector is too long (too many entries) * An individual memo entry is
  // too long (too many bytes) * The combined length of all memos is too large
  // (too many bytes) * The internal queue is full (back pressure) The trap
  // message will contain the reason in descriptive text format.
  // 
  // `submitAndExecute` is subject to ingress message inspection.  Any call that
  // would trap for any of the above reasons will be rejected during inspection.
  // This will lead to an http 500 error. The caller will not be able to learn
  // the specific reason why the call failed.
  // 
  // The aggregator does not check if the accounts exist, if the caller has
  // access to the accounts or if there are sufficient funds. Those kind of
  // errors will only be caught later during processing in the ledger. 
  // 
  // Backwards compatibility: In the future, new transaction types can be
  // introduced as new variant cases in the `TxInput` argument.  New fields can
  // be added to the returned record. Old client code will not see those fields.
  // If the structure of GlobalId changes then it is advisable to introduce a
  // new function replacing this `submitAndExecute`.  New cases can be added to
  // the GidStatus variant because it is wrapped in an `opt` (see also the
  // `gidStatus` query below).
  submitAndExecute : (TxInput) -> (record { GlobalId; opt GidStatus });
  
  // QUERIES

  // `gidStatus` returns the current status of a gid.
  //
  // In general, the typical process to track a transaction after submission to
  // the aggregator is as follows:
  //
  // 1. Query the aggregator for the gid. That will return one of "queued",
  // "pending" or "unavailable".
  //   If it is "pending" or "unavailable" then query the ledger in step 2.
  //   If it is "queued" then repeat step 1. after X milliseconds. This means
  //   we poll the aggregator and watch the queue distance go down until the
  //   response is different from "queued".
  //
  // 2. Query the ledger for the given `gid`. That will return one of
  // "successful", "failed" or "awaited". 
  //   If it is "successful" or "failed" then the transaction has been processed
  //   and that is the final state.
  //   If it is "awaited" then repeat step 2. after X milliseconds. This means
  //   we poll the ledger until the transaction is processed.
  //
  // The above merely showcases the happy case. There are a number of edge cases
  // that account for communication failures between aggregator and ledger on
  // the IC level, frozen canisters, canister upgrades, etc. The full process
  // can be seen in the README.
  //  
  // The function will trap if the nats in global id are larger than 64 bits.
  // 
  // Backwards compatibility: 
  //
  // New fields can be added to the returned record.  Old code will not see
  // those fields. 
  // 
  // If the internal structure of GlobalId changes then it is advisable to
  // introduce a new function replacing this `gidStatus`.
  // 
  // New cases can be added to the GidStatus variant because it is wrapped in an
  // `opt`. Old code that does not know the new case will see the whole status
  // as `null`.  
  // 
  // For example, if we want to add the ability to cancel transactions that are
  // already in the queue then we can add a case `canceled` to the GidStatus
  // variant. An old frontend that is not aware of the case `canceled` would see
  // `null` as the status if it queries a transaction that is in that state.
  // However, this is not a problem because a frontend queries only its own
  // transactions. And if the frontend does not know about the cancelation
  // feature then none of its transactions will be in that state.
  gidStatus : (GlobalId) -> (record { opt GidStatus }) query; 
};
  