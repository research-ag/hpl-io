// common definitions with aggregator
type AssetId = nat;
type SubId = nat;
type VirId = nat;

// Backward compatibility:
//
// TODO: Can additional variant cases be added?
// Are the variants wrapped in opts?
type AccountType = variant { ft : AssetId; };
type AccountState = variant { ft : FtState };
type FtState = record { AssetId; nat }; // pair (asset id, quantity)

//
type Expiration = variant {
  None;
  Timestamp : nat64;
};

// state of a virtual account from the perspective of the owner
type VirtualAccountState = record {
  state : AccountState;
  backingAccount : SubId;
  accessPrincipal : principal;
  expiration : Expiration;
};

// state of a virtual account from the perspective of the remote principal
type RemoteState = record {
  state : AccountState;
  accessPrincipal : principal; // TBD: could remove this
  expiration : Expiration;
};

//
type OpenAccounts_Result = variant {
  ok : record { first : SubId };
  err : opt variant {
    NoSpaceForPrincipal;
    NoSpaceForSubaccount;
    InvalidArguments : text;
      // "UnknownFtAsset"
  };
};

type Open_Result = variant {
  ok : record { id : VirId };
  err : opt variant {
    NoSpaceForAccount;
    InvalidArguments : text;
      // "MismatchInAsset"
      // "UnknownSubaccount" means unknown backing subaccount
      // "InvalidExpirationTime"
  };
};

type Delete_Result = variant {
  ok;
  err : opt variant {
    DeletedVirtualAccount; // means had already been deleted before
    InvalidArguments : text;
      // "UnknownVirtualAccount" 
  };
};

type VirtualAccountUpdate = record {
  state : opt StateUpdate;
  backingAccount : opt SubId;
  expiration : opt Expiration;
};
type StateUpdate = variant { 
  ft : variant {
    set : nat;
    increment : nat;
    decrement : nat;
  };
};

type Update_Result = variant {
  ok : variant {
    ft : record {
      balance : nat;
      delta : int;
    };
  };
  err : opt variant {
    DeletedVirtualAccount;
    InsufficientFunds;
    InvalidArguments : text;
      // "InvalidExpirationTime"
      // "MismatchInAsset"
      // "UnknownSubaccount"
      // "UnknownVirtualAccount"
  };
};

type TxStatus = record {
  // 0 : GidStatus at aggregator
  // 1 : GidStatus at ledger
  // 2 : Tx result
  1 : opt variant {
    awaited : Principal; // not yet received, return aggregator principal
    processed; // received and processed
    dropped; // will not be accepted anymore
  };
  2 : opt variant {
    failed : opt ProcessingError; // failed
    succeeded : TxOutput; // suceeded
  };
};
type TxOutput = variant {
  ftTransfer : record {
    amount : nat;
    fee : nat;
  };
};
// amount + fee was deducted at sender, amount was credited at receiver
type ProcessingError = variant {
  ftTransfer : variant {
    DeletedVirtualAccount;
    InsufficientFunds;
    InvalidArguments : text;
      // "MismatchInAsset"
      // "MismatchInRemotePrincipal", means no access
      // "NotAController"
      // "UnknownFtAsset"
      // "UnknownPrincipal"
      // "UnknownSubaccount"
      // "UnknownVirtualAccount"
  };
};

type GlobalId = record { nat; nat };

service : () -> {
  // UPDATES

  // non-public account management queries 
  accountState : (SubId) -> (opt AccountState) query; 
    // access by owner
    // trap if caller unknown
    // null if subId unknown
    // null if a new account state variant other than ft is returned (upgrade)
  virtualAccountState : (VirId) -> (opt VirtualAccountState) query; 
    // access by owner (not by access principal)
    // trap if caller unknown
    // null if virId unknown or deleted 
    // null if a new account state variant other than ft is returned (upgrade)
  nAccounts : () -> (nat) query; 
    // trap if caller unknown
  nVirtualAccounts : () -> (nat) query; 
    // trap if caller unknown

  remoteState : (principal, VirId) -> (opt RemoteState) query; 
    // access by access principal (not by owner)
    // trap if principal does not exist
    // trap if virid unknown or deleted
    // trap if caller != accessPrincipal
    // null if a new account state variant other than ft is returned (upgrade)

  // account management updates
  openAccounts : (record { n : nat; type : AccountType }) -> (OpenAccounts_Result); 
    // caller unknown is not possible because the caller gets auto-registered
  openVirtualAccount : (VirtualAccountState) -> (Open_Result); 
    // trap if caller unknown
  deleteVirtualAccount : (VirId) -> (Delete_Result); 
    // trap if caller unknown
  updateVirtualAccount : (VirId, VirtualAccountUpdate) -> (Update_Result); 
    // trap if caller unknown

  // QUERIES

  ftSupply : (AssetId) -> (opt nat) query;
    // null if assetid unknown
  ftController : (AssetId) -> (opt principal) query;
    // null if assetid unknown
  aggregators : () -> (vec principal) query; // list all aggregators

  // If the stream id in GlobalId is not known, i.e. has not yet been issued, 
  // then there must be an error on the side of the caller. In this case,
  // txStatus returns `record { }` which means the options in the record are
  // both null.
  txStatus : (GlobalId) -> (TxStatus) query;
};
