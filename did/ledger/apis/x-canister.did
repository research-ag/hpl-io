type AssetId = nat;

type SubId = nat;
type VirId = nat;

type GlobalId = record { nat; nat };
type PriorId = record { nat; nat; nat };

type Asset = record {
  AssetId;
  nat;
};

type AccountReference = variant {
  sub : SubId;
  vir : record {
    principal;
    VirId;
  };
};

type AccountArgument = variant {
  sub : SubId;
  vir : record {
    principal;
    VirId;
  };
  mint;
};

type Tx = record {
  map : vec principal;
  flows : vec record {
    ownerIndex : nat;
    account : variant {
      air;
      sub : SubId;
      vir : record { principal; VirId };
    };
    delta : record {
      AssetId;
      variant { maxIn; maxOut; amount : int };
    };
  };
  memo : vec blob;
  feeMode : variant { fraction; noFee };
};
type TxInput = variant {
  v1 : record {
    map : vec record {
      owner : opt principal;
      inflow : vec record {
        AccountReference;
        Asset;
      };
      outflow : vec record {
        AccountReference;
        Asset;
      };
      mints : vec Asset;
      burns : vec Asset;
    };
    memo : vec blob;
  }
};

type ApproveReject_Result = variant {
  err : variant {
    AlreadyApproved;
    AlreadyRejected;
    NoPart;
    NotFound;
    WrongAggregator;
  };
  ok : null;
};

type Execute_Result = variant {
  err : variant {
    DeletedVirtualAccount;
    InsufficientFunds;
    MismatchInAsset;
    MismatchInRemotePrincipal;
    NoPart;
    NotAController;
    NotApproved;
    NotFound;
    SuspendedVirtualAccount;
    UnknownFtAsset;
    UnknownPrincipal;
    UnknownSubaccount;
    UnknownVirtualAccount;
    UnsupportedFeeMode;
    WrongAggregator;
  };
  ok : GlobalId;
};

type SubmitAndExecuteError = variant {
  DeletedVirtualAccount;
  IncorrectOwnerIndex;
  InsufficientFunds;
  MismatchInAsset;
  MismatchInRemotePrincipal;
  NonZeroAssetSum;
  NotAController;
  NotApproved;
  SuspendedVirtualAccount;
  TooLargeAssetId;
  TooLargeFtQuantity;
  TooLargeMemo;
  TooLargeSubaccountId;
  TooLargeVirtualAccountId;
  TooManyContributions;
  TooManyFlows;
  UnknownFtAsset;
  UnknownPrincipal;
  UnknownSubaccount;
  UnknownVirtualAccount;
  UnsupportedFeeMode;
  UnsupportedMaxFlows;
};

type LedgerXcAPI = service {

  // ======================== TRANSACTIONS API ======================
  // queries
  priorTxDetails : (PriorId) -> (variant {
    err : variant {
      NotFound;
      WrongAggregator;
    };
    ok : record {
      gid : opt GlobalId;
      status : variant {
        failed : variant {
          DeletedVirtualAccount;
          InsufficientFunds;
          MismatchInAsset;
          MismatchInRemotePrincipal;
          NotAController;
          SuspendedVirtualAccount;
          UnknownFtAsset;
          UnknownPrincipal;
          UnknownSubaccount;
          UnknownVirtualAccount;
          UnsupportedFeeMode;
        };
        pending : vec bool;
        processed : GlobalId;
        rejected;
      };
      submitter : principal;
      tx : record {
        map : vec principal;
        flows : vec record {
          ownerIndex : nat;
          account : variant {
            sub : SubId;
            vir : record {
              principal;
              VirId;
            };
            air;
          };
          delta : record {
            AssetId;
            variant { maxIn; maxOut; amount : int };
          };
        };
        feeMode : variant { fraction; noFee };
        memo : vec blob;
      };
    };
  }) query;
    // get transaction details
    // NotFound means the transaction id is unknown
    // (was never known or has already been deleted)

  // updates
  processBatch : (nat, vec Tx, nat, bool) -> (variant { err; ok : nat64 });
    // process a batch of transaction, caller must be an aggregator

  submit : (TxInput) -> (variant {
    err : variant {
      IncorrectOwnerIndex;
      NoSpace;
      NonZeroAssetSum;
      TooLargeAssetId;
      TooLargeFtQuantity;
      TooLargeMemo;
      TooLargeSubaccountId;
      TooLargeVirtualAccountId;
      TooManyContributions;
      TooManyFlows;
      UnsupportedMaxFlows;
    };
    ok : PriorId;
  });
    // Create a new transaction request, which requires approval by one or more contributors
    // Here we init it and put to the lookup table.
    // If the lookup table is full, we try to reuse the slot with oldest unapproved request

  submitAndExecute : (TxInput) -> (variant {
    err : SubmitAndExecuteError;
    ok : record {
      GlobalId;
      variant {
        ftTransfer : record {
          amount : nat; // amount + fee was deducted at sender, amount was credited at receiver
          fee : nat;
        };
      };
    };
  });
    // Create and process a new transaction request, which does not require any approvals
    // Here we do not use the lookup table.

  simpleTransfer : (AccountArgument, AccountArgument, AssetId, variant { amount : nat; max }, opt blob) -> (variant {
    err : variant {
      DeletedVirtualAccount;
      InsufficientFunds;
      MismatchInAsset;
      MismatchInRemotePrincipal;
      NonZeroAssetSum;
      NotAController;
      SuspendedVirtualAccount;
      TooLargeMemo;
      UnknownFtAsset;
      UnknownPrincipal;
      UnknownSubaccount;
      UnknownVirtualAccount;
      UnsupportedFeeMode;
      UnsupportedMaxFlows;
    };
    ok : record { nat; GlobalId };
  });
    // Build and process a new transaction request with transfer from one account to another

  approve : (PriorId) -> (ApproveReject_Result);
    // approve request

  approveAndExecute : (PriorId) -> (variant {
    err : variant {
      AlreadyApproved;
      AlreadyRejected;
      DeletedVirtualAccount;
      InsufficientFunds;
      MismatchInAsset;
      MismatchInRemotePrincipal;
      NoPart;
      NotAController;
      NotApproved;
      NotFound;
      SuspendedVirtualAccount;
      UnknownFtAsset;
      UnknownPrincipal;
      UnknownSubaccount;
      UnknownVirtualAccount;
      UnsupportedFeeMode;
      WrongAggregator;
    };
    ok : GlobalId;
  });
    // Approve request and process the transaction. Works only this approvement is the last required approvement.
    // If this approvement is not enough for processing, approval will not be recorded

  execute : (PriorId) -> (Execute_Result);
    // Process fully approved and not executed yet transaction

  reject : (PriorId) -> (ApproveReject_Result);
    // Reject request. It marks request as rejected, but don't remove the request from unapproved list,
    // so it's status can still be queried until overwritten by newer requests
  // ======================== TRANSACTIONS API ======================

  // ======================== ADMIN/DEBUG API =======================
  // queries
  aggregatorPrincipal : (nat) -> (variant {
    ok : principal;
    err : variant { NotFound };
  }) query;
    // return the principal of the aggregator by given stream id
    // NotFound if it does not exist

  allAssets : (principal) -> (variant {
    ok : vec record {
      asset : record {
        AssetId;
        nat;
      };
    };
    err : variant { UnknownPrincipal };
  }) query;
    // return all assets (i.e. all subaccounts) of the given owner
    // UnknownPrincipal if the given owner is not registered

  stats : () -> (record {
    txs : record {
      processed : nat;
      succeeded : nat;
      failed : nat;
    };
    boardTxs : record {
      submitted : nat;
      rejected : nat;
      forwarded : nat;
    };
    canisterStatus : record {
      cyclesBalance : nat;
      memorySize : nat;
      heartbeats : nat;
    };
    registry : record {
      accounts : nat;
      assets : nat;
      owners : nat;
      streams : nat;
    };
  }) query;
 
  // updates
  addAggregator : (principal) -> ();
  // ======================== ADMIN/DEBUG API =======================
};

service : () -> LedgerXcAPI;
